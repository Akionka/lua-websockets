{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"A binding for libwebsockets.","name":"Lua-websockets","body":"# About\r\nA Lua binding for [libwebsockets](http://git.warmcat.com/cgi-bin/cgit/libwebsockets) which provides easy websocket server functionality for Lua. It works standalone (using the built-in event-loop) or it can be employed together with event frameworks like [lua-ev](https://github.com/brimworks/lua-ev) by providing hooks to get access to raw filedescriptors.\r\n\r\nWhereas it is very easy to provide a websockets message oriented server via libwebsockets (and thus lua-webscokets), its means for handle HTTP are very limited and rather inconvient and mainly for providing self-containing tests/examples. If you are looking for a feature rich webserver framework, have a look at [orbit](http://keplerproject.github.com/orbit/) or others. \r\n\r\nIt is no problem to work with a \"normal\" webserver and lua-websockets side by side (but on different ports!), since websockets are not subject of the 'Same origin policy'.\r\n\r\n# Usage\r\n## Example 1: Simple echo server\r\nThis implements a basic echo server via Websockets protocol. Once you are connected with the server, all messages you send will be returned ('echoed') by the server immediately.\r\n\r\n```lua\r\n-- load module\r\nlocal websockets = require'websockets'\r\n\r\n-- you always need one context object\r\nlocal context = websockets.context({\r\n  -- listen on port 8080\r\n  port = 8080,\r\n  -- the protocols field holds\r\n  --   key: protocol name\r\n  --   value: callback on new connection\r\n  protocols = {\r\n    -- this callback is called, whenever a new client connects.\r\n    -- ws is a new websocket instance\r\n    echo = function(ws)\r\n      -- on_receive is called whenever data / a message \r\n      -- has been received from the client\r\n      ws:on_receive(function(ws,data)\r\n        -- write/echo back the data\r\n        ws:write(data,websockets.WRITE_TEXT)\r\n      end)\r\n    end\r\n  }\r\n})\r\n\r\n-- use the libwebsocket loop to dispatch events.\r\nwhile true do\r\n   context:service(100000)\r\nend   \r\n```\r\n\r\nThere are some important points to notice here:\r\n  - You need to load the websockets module via `require`\r\n  - You have to define one context which describes 'global' attributes and behaviour\r\n  - At least one protocol must be defined ('echo' in this example).\r\n    The callback specified is called for every new connection. Inside you may register a callback,\r\n    which is called whenever data is received.\r\n  - You must somehow kickstart the service loop.\r\n    In this example libwebsocket's built in \"event-loop\" is used (via `context:service`).\r\n\r\nConnect to the from Javascript (e.g. chrome's debugging console) like this:\r\n```Javascript\r\nvar echoWs = new WebSocket('ws://127.0.0.1:8002','echo');\r\n```\r\nIn opposite to test-server.lua the server does not handle HTTP requests though. If you want to handle HTTP too, implement the context's `on_http` callback.\r\n\r\n## Example 2: test-server.lua\r\nTo see a complete working example, have a look at test-server.lua, which is the Lua equivalent to the test-server.c example from the libwebsockets package. If you have downloaded or cloned the lua-websockets package, you can start the test-server.lua like this:\r\n\r\n```shell\r\nlua test-server/test-server.lua test-server/ \r\n```\r\nNow the test-server is running and awaiting clients to connect.\r\nYou can connect with one or more browser windows on http://localhost:8002 or http://127.0.0.1:8002 and play around.\r\n\r\n# API\r\nlua-websockets' API tries to be as close to the underlying libwebsockets as possible. In most cases the original libwebsockets documentation is more detailed then this one. Therefor a mapping between the orginal C API and lua-websockets is gven:\r\n\r\n<table>\r\n  <tr><th>lua-websockets</th><th>C API</th></tr>\r\n  <tr><td>websockets.context</td><td>libwebsocket_context_create<td></tr>\r\n  <tr><td>websockets.context</td><td>libwebsocket_context_create<td></tr>\r\n</table>\r\n\r\n## websockets table\r\n\r\nThe websockets table is the modules root table/namespace.\r\n\r\n### websockets.WRITE_TEXT\r\n\r\nTo be used as type with websocket:write(data,type)\r\n\r\n### websockets.WRITE_BINARY\r\n\r\nTo be used as type with websocket:write(data,type)\r\n\r\n### websockets.context(config)\r\n\r\n```lua\r\nlocal context = websockets.context({\r\n   -- the port the websockets server listens for incoming connections\r\n   port = 8001,\r\n   -- a callback for http requests\r\n   on_http = handle_http,\r\n   -- an (optional) callback for a new fd to service; only\r\n   -- relevant when using external event-loop\r\n   on_add_fd = register_fd, --function, optional\r\n   -- a (optional) callback for a fd which is no more to service; only\r\n   -- relevant when using external event-loop\r\n   on_del_fd = unregister_fd, --function, optional\r\n   -- a map of protocol names and callbacks for this protocol\r\n   -- at least one protocol must be provided.\r\n   protocols = {\r\n     ['echo'] = echo_cb,\r\n     ['super-test'] = super_test_cb\r\n   },\r\n   -- a (optional) string desrcibing the interface to listen on\r\n   interf = 'eth0',\r\n   -- a (optional) string specifying the path to the ssl certificate\r\n   ssl_cert_path, \r\n   -- a (optional) string specifying the path to the ssl private key\r\n   ssl_private_key_path,\r\n   gid, --int, optional\r\n   uid, --int, optional\r\n   options --int, optional\r\n})\r\n```\r\n\r\n## context methods\r\n\r\nA context can be created via websockets.context(...).\r\n\r\n### context:destroy()\r\n```lua\r\ncontext:destroy()\r\n```\r\nDestroys a context. Behaves like `libwebsocket_context_destroy`.\r\nThe context's __gc metamethod calls destroy if necessary (garbage collection), so in general this is not required to be called explicitly. \r\n\r\n### context:service(timeout_ms)\r\n```lua\r\nwhile true do\r\n      context:service(2000)\r\nend\r\n```\r\nServices the context's outstanding io on ALL open fds. Behaves like\r\n`libwebsocket_service`. The integer `timeout_ms` value defaults to 0\r\n(no timeout, return immediatly after outstanding IO was performed).\r\n\r\n### context:service_fd(fd,revent1,revent2,...)\r\n```lua\r\n-- example to employ service_fd with lua-ev.\r\nlocal context\r\ncontext = websockets.context{\r\n  on_add_fd = function(fd)\r\n    local io = ev.IO.new(function(_,_,revents)\r\n      -- specifically handle THIS fd with THIS revents               \r\n      context:service_fd(fd,revents)\r\n    end,fd,ev.READ)\r\n    io:start(ev.Loop.default)\r\n  end,\r\n   ...\r\n}\r\n```\r\nServices the fd's specified revent related actions. Behaves like\r\n`libwebsocket_service_fd`. At least one revent must be\r\nspecified. Multiple revents are bit OR'ed. The revents are not\r\ninterpreted by lua-websockets layer but directly forwarded to\r\n`libwebsocket_service_fd`.\r\n\r\n### context:broadcast(protocol_name,data)\r\n```lua\r\ncontext:broadcast('echo','hello')\r\n```\r\nBroadcasts data for all open websockets of kind `protocol_name`. Behaves\r\nlike `libwebsockets_broadcast`. Both parameters are strings. The\r\nbehavior of individual websockets may be changed with websocket:on_broadcast.\r\n\r\n### context:canonical_hostname()\r\n```lua\r\nlocal hostname = context:canonical_hostname()\r\n```\r\nReturns the context's canonical hostname (machine name). Behaves like\r\n`libwebsocket_canonical_hostname`.\r\n\r\n### context:fork_service_loop()\r\nBehaves like `libwebsockets_fork_service_loop`.\r\n\r\n## websocket methods\r\n\r\nA websocket can not be explicitly created, instead it gets passed to\r\nvarious callback methods, e.g. the protocol connect callback handler\r\n(see websockets.context)\r\n\r\n### websocket:write(data,write_type)\r\n```lua\r\nwebsocket:write('hello',websockets.WRITE_TEXT)\r\n```\r\nWrites data to websocket. The write_type must be\r\nwebsockets.WRITE_XYZ or nil (defaults to WRITE_TEXT). Behaves like `libwebsocket_write`.\r\n\r\n### websocket:on_closed(callback)\r\n```lua\r\nwebsocket:on_closed(function() print('bye') end)\r\n```\r\nRegisters an on_closed callback on the websocket. The callback gets no\r\nparameters passed in.\r\n\r\n### websocket:on_broadcast(callback_or_mode)\r\n```lua  \r\nwebsocket:on_broadcast(websockets.WRITE_TEXT) --forward broadcast as text\r\nwebsocket:on_broadcast(websockets.WRITE_BINARY) --forward broadcast binary\r\nwebsocket:on_broadcast(function(ws,data) -- intercept broadcast\r\n  ws:write(data..'hello',websockets.WRITE_TEXT)\r\nend)\r\n```\r\nRegisters an on_broadcast callback on the websocket if\r\ncallback_or_mode is a function. If callback_or_mode is int\r\n(websockets.WRITE_XYZ, any incoming braodcast events forward the message with the respective type. See\r\n`libwebsockets_broadcast` and and handling of `LWS_CALLBACK_BROADCAST`.\r\n\r\n### websocket:on_receive(callback)\r\n```lua\r\nwebsocket:on_receive(function(ws,data)\r\n  ws:write(data,websockets.WRITE_TEXT)\r\nend)\r\n```\r\nRegisters a receive handler for incoming data. The callback gets the\r\nwebsocket and the data passed as arguments.\r\n\r\n### websocket:broadcast(data)\r\n```lua\r\nws:broadcast('all echo hello')\r\n```\r\nBroadcasts data to all websockets of the same protocol. Behaves like `libwebsockets_broadcast`.\r\n\r\n### websocket:get_socket_fd()\r\nReturns the websocket's socket fd. Useful when using other event loop,\r\ne.g. lua-ev.\r\n\r\n### websocket:close(reason)\r\nCloses the websocket with the optional integer reason. Behaves like `libwebsockets_close_and_free_session`.\r\n\r\n### websocket:get_peer_addresses()\r\n```lua\r\nlocal name,rip = ws:get_peer_addresses()\r\n```\r\nBehaves like `libwebsocket_get_peer_addresses`.\r\n\r\n### websocket:remaining_packet_payload()\r\n```lua\r\nlocal remaining = ws:remaining_packet_payload()\r\n```\r\nBehaves like `libwebsocket_remaining_packet_payload`.\r\n\r\n### websocket:rx_flow_control(enable)\r\n```lua\r\nws:rx_flow_control(true)\r\n```\r\nEnables / disables rx flow control. Behaves like `libwebsocket_remaining_packet_payload`.\r\n\r\n### websocket:serve_http_file(filename,content_type)\r\n```lua\r\nws:serve_http_file('./index.html','text/html')\r\n```\r\nServes a file from filesystem. Can only be called from within\r\ncontext's on_http callback. Behaves like\r\n`libwebsockets_serve_http_file`.\r\n\r\n# Install\r\n\r\n## Install lua-websockets\r\n[libwebsockets](http://git.warmcat.com/cgi-bin/cgit/libwebsockets) must be installed before lua-websockets can be installed. After having the _latest_ libwebsockets in place, lua-websockets can be installed. At the bottom of the page there are some instruction how to build libwebsockets for Unix and OSX. The prefered way is to install a tagged version from luarocks repository:\r\n\r\n```shell \r\n$ sudo luarocks install lua-websockets\r\n```\r\n\r\nIf you need the most recent version from github, you have to clone and perform a luarocks make:\r\n\r\n```shell \r\n$ git clone git://github.com/lipp/lua-websockets.git\r\n$ cd lua-websockets\r\n$ luarocks make rockspecs/lua-websockets-scm-1.rockspec \r\n```\r\n\r\n## Build and install libwebsockets\r\n\r\n### Build libwebsockets with Ubuntu\r\nThis most problably applies to most other Linuxes.\r\nDownload the recent version and unpack. cd into the unpacked directory. \r\n```shell \r\n$ ./configure\r\n$ make\r\n$ sudo make install\r\n```\r\n\r\n### Build with OSX\r\nYou need to install: \r\n  - autoconf\r\n  - automake\r\n  - libtool\r\n\r\nI was successfull using homebrew and using macports.\r\nThen do the following.\r\n```shell \r\n$ autoreconf\r\n$ glibtoolize\r\n$ ./configure --enable-nofork\r\n$ make\r\n$ sudo make install\r\n```\r\n\r\n","google":""}