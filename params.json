{"name":"Lua-websockets","tagline":"A binding for libwebsockets.","body":"# About\r\n\r\nThis project provides Lua modules for [Websocket Version 13](http://tools.ietf.org/html/rfc6455) conformant clients and servers. [![Build Status](https://travis-ci.org/lipp/lua-websockets.png?branch=pure-lua)](https://travis-ci.org/lipp/lua-websockets)\r\n\r\nClients are available in three different flavours:\r\n\r\n  - synchronous \r\n  - coroutine based ([copas](http://keplerproject.github.com/copas))\r\n  - asynchronous ([lua-ev](https://github.com/brimworks/lua-ev))\r\n\r\nServers are available as two different flavours:\r\n\r\n  - coroutine based ([copas](http://keplerproject.github.com/copas))\r\n  - asynchronous ([lua-ev](https://github.com/brimworks/lua-ev))\r\n\r\n\r\nA webserver is NOT part of lua-websockets. If you are looking for a feature rich webserver framework, have a look at [orbit](http://keplerproject.github.com/orbit/) or others. It is no problem to work with a \"normal\" webserver and lua-websockets side by side (two processes, different ports), since websockets are not subject of the 'Same origin policy'.\r\n\r\n# Usage\r\n## Example 1: Simple copas echo server\r\nThis implements a basic echo server via Websockets protocol. Once you are connected with the server, all messages you send will be returned ('echoed') by the server immediately.\r\n\r\n```lua\r\nlocal copas = require'copas'\r\n\r\n-- create a copas webserver and start listening\r\nlocal server = require'websocket'.server.copas.listen\r\n{\r\n  -- listen on port 8080\r\n  port = 8080,\r\n  -- the protocols field holds\r\n  --   key: protocol name\r\n  --   value: callback on new connection\r\n  protocols = {\r\n    -- this callback is called, whenever a new client connects.\r\n    -- ws is a new websocket instance\r\n    echo = function(ws)\r\n      while true do\r\n        local message = ws:receive()\r\n        ws:send(message)\r\n      end\r\n    end\r\n  }\r\n})\r\n\r\n-- use the copas loop\r\ncopas.loop()\r\n```\r\n\r\n## Example 2: Simple lua-ev echo server\r\nThis implements a basic echo server via Websockets protocol. Once you are connected with the server, all messages you send will be returned ('echoed') by the server immediately.\r\n\r\n```lua\r\nlocal ev = require'ev'\r\n\r\n-- create a copas webserver and start listening\r\nlocal server = require'websocket'.server.ev.listen\r\n{\r\n  -- listen on port 8080\r\n  port = 8080,\r\n  -- the protocols field holds\r\n  --   key: protocol name\r\n  --   value: callback on new connection\r\n  protocols = {\r\n    -- this callback is called, whenever a new client connects.\r\n    -- ws is a new websocket instance\r\n    echo = function(ws)\r\n      ws:on_message(function(ws,message)\r\n        ws:send(message)\r\n      end)\r\n    end\r\n  }\r\n})\r\n\r\n-- use the lua-ev loop\r\nev.Loop.default:loop()\r\n```\r\n\r\n## Running test-server examples\r\n\r\nThe folder test-server contains two re-implementations of the [libwebsocket](http://git.warmcat.com/cgi-bin/cgit/libwebsockets/) test-server.c example.\r\n\r\n```shell\r\ncd test-server\r\nlua test-server-ev.lua\r\n```\r\n\r\n```shell\r\ncd test-server\r\nlua test-server-copas.lua\r\n```\r\n\r\nConnect to the from Javascript (e.g. chrome's debugging console) like this:\r\n```Javascript\r\nvar echoWs = new WebSocket('ws://127.0.0.1:8002','echo');\r\n```\r\n\r\n# Dependencies\r\n\r\nThe client and server modules depend on:\r\n\r\n  - luasocket\r\n  - lpack\r\n  - luabitop (if not using Lua 5.2 nor luajit)\r\n  - copas (optionally)\r\n  - lua-ev (optionally)\r\n\r\n# Install\r\n\r\n```shell \r\n$ git clone git://github.com/lipp/lua-websockets.git\r\n$ cd lua-websockets\r\n$ luarocks make rockspecs/lua-websockets-scm-1.rockspec \r\n```\r\n\r\n# Tests\r\n\r\nRunning tests requires:\r\n\r\n  - [busted with async test support](https://github.com/lipp/busted)\r\n  - [node](http://nodejs.org/)\r\n  - [node-websocket](https://github.com/Worlize/WebSocket-Node)\r\n\r\n```shell\r\n./test.sh\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}